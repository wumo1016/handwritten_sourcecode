## promise主要解决了什么问题
- 1.可以链式调用(解决了嵌套回调的问题)
- 2.同步并发

## 实现步骤
- 1.Promise是一个具有then方法的对象或者函数(规范)(可以用类实现)
- 2.一个Promise必须具有三种状态(pending,fulfilled,rejected)(规范)
  - 默认状态为pending
  - pending状态时，可以转换为fulfilled或rejected状态
  - fulfilled状态时，必须有一个value，且不能过渡到其他状态
  - rejected状态时，必须有一个reason，且不能过渡到其他状态
- 3.Promise传入一个执行器函数
  - 执行器函数立即执行，并接受两个函数resolve,reject；用于改变状态，且只有pending状态才能被改变
  - resolve接受一个value参数，并且需要保存
  - reject接受一个reason参数，并且需要保存
- 4.一个Promise必须有一个then方法，接受两个参数(onFulfilled,onRejected)(规范)
  - onFulfilled和onRejected都必须异步执行(规范)，这里就可以使用微任务(MutationObserver和process.nextTick)和宏任务(setTimeout和setImmediate(仅IE))来包裹
  - 这两个参数可选，如果不是函数，需要将其包装成函数
  - 如果onFulfilled是一个函数，必须在状态变为fulfilled之后执行，且将value作为第一个参数
  - 如果onRejected是一个函数，必须在状态变为rejected之后执行，且将reason作为第一个参数
  - 如果状态时异步改变的，就需要将onFulfilled,onRejected保存起来，因为then可以调用多次，所以需要使用数组保存，然后等到状态改变的时候，循环相应的数组遍历执行(发布订阅模式)
  - then必须返回一个新的Promise promise2，以便链式调用，而且需要将
  - onFulfilled和onRejected都返回一个值x，需要使用一个处理函数resolvePromise来处理
- 5.处理函数resolvePromise
  - 接受4个参数，当前promise、onFulfilled或onRejected返回的值x，resolve，reject
  - 如果promise和x引用相同的对象，则reject一个TypeError
  - 如果x是对象或函数
    - 定义 then = x.then 如果出错则 reject(e)
      - 如果then是函数，调用then，并将then中的this修改为x，然后第一个函数调用resolve并传入参数y，第二个调用reject并传入参数r
      - then不是函数，直接resolve(x)
      - 别人的then可能没有做状态判断，这样就可能改变多次状态，所以为了避免，需要做一个标记，状态一经改变就不能再变
  - 如果x是普通值，直接reslove(x)
